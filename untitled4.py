# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fAY69IigHE17oBhGw4eovDWMacmQvGQC
"""

# ===============================
# APP STREAMLIT ‚Äì PREVIS√ÉO DE OBESIDADE
# ===============================

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, ConfusionMatrixDisplay
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.naive_bayes import GaussianNB

# -------------------------------
# CONFIG STREAMLIT
# -------------------------------
st.set_page_config(page_title="Previs√£o de Obesidade", layout="centered")

st.title("üè• Previs√£o de Obesidade")
st.write(
    """
    Este sistema utiliza **Machine Learning** para auxiliar profissionais de sa√∫de
    na **previs√£o de obesidade**, com base em caracter√≠sticas cl√≠nicas e comportamentais.
    """
)

# -------------------------------
# CARREGAR DADOS
# -------------------------------
@st.cache_data
def load_data():
    df = pd.read_csv("Obesity.csv")
    df["BMI"] = df["Weight"] / (df["Height"] ** 2)
    return df

df = load_data()

st.subheader("üìä Vis√£o geral do dataset")
st.dataframe(df.head())

# -------------------------------
# FEATURES E TARGET
# -------------------------------
X = df.drop("Obesity", axis=1)
y = df["Obesity"]

num_features = ["Age", "Height", "Weight", "BMI"]
cat_features = [col for col in X.columns if col not in num_features]

# -------------------------------
# PR√â-PROCESSAMENTO
# -------------------------------
preprocess = ColumnTransformer([
    ("cat", OneHotEncoder(handle_unknown="ignore", sparse_output=False), cat_features),
    ("num", "passthrough", num_features)
])

# -------------------------------
# SPLIT
# -------------------------------
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# -------------------------------
# MODELOS
# -------------------------------
gb = Pipeline([
    ("prep", preprocess),
    ("model", GradientBoostingClassifier(random_state=42))
])

nb = Pipeline([
    ("prep", preprocess),
    ("model", GaussianNB())
])

# -------------------------------
# TREINAR
# -------------------------------
gb.fit(X_train, y_train)
nb.fit(X_train, y_train)

# -------------------------------
# AVALIA√á√ÉO
# -------------------------------
gb_preds = gb.predict(X_test)
nb_preds = nb.predict(X_test)

gb_acc = accuracy_score(y_test, gb_preds)
nb_acc = accuracy_score(y_test, nb_preds)

st.subheader("üìà Acur√°cia dos Modelos")

col1, col2 = st.columns(2)
col1.metric("Gradient Boosting", f"{gb_acc:.2%}")
col2.metric("Naive Bayes", f"{nb_acc:.2%}")

# -------------------------------
# MATRIZ DE CONFUS√ÉO
# -------------------------------
st.subheader("üîé Matriz de Confus√£o ‚Äì Gradient Boosting")

cm = confusion_matrix(y_test, gb_preds)
fig, ax = plt.subplots(figsize=(6, 5))
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=gb.classes_)
disp.plot(ax=ax, cmap="Blues", values_format="d")
st.pyplot(fig)

# -------------------------------
# RELAT√ìRIO
# -------------------------------
with st.expander("üìÑ Relat√≥rio de Classifica√ß√£o (Gradient Boosting)"):
    st.text(classification_report(y_test, gb_preds))